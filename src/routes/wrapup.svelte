<script lang="ts">
	import Chart from "chart.js/auto";
	import {onMount} from "svelte";
	import {comments, answerlogs, round1, round2} from "./_stats.json"
	let chartTime, ctxTime, dataTime;
	let chartGuesses, ctxGuesses, dataGuesses;
	let chartRatings, ctxRatings, dataRatings;
	let configTime, configGuesses, configRatings
	let chart1, chart2, chart3

	const puzzleLabels = ['1-1','1-2','1-3','1-4','1-5','1-final','2-1','2-2','2-3','2-4','2-final',];

	onMount(()=>{
		dataTime = {
			labels: round1.map((e,i)=>''),
			datasets: [
				{
					label: 'เวลาที่ใช้ในด่าน 1',
					backgroundColor: 'rgb(132, 99, 132)',
					borderColor: 'rgb(132, 99, 132)',
					data: round1.filter((e)=>e.timetotal < 36000000).sort((a,b)=>{return a.timetotal-b.timetotal}).map(e=>e.timetotal/3600000)
				},
				{
					label: 'เวลาที่ใช้ในด่าน 2',
					backgroundColor: 'rgb(50, 132, 132)',
					borderColor: 'rgb(50, 132, 132)',
					data: round2.filter((e)=>e.timetotal < 36000000).sort((a,b)=>{return a.timetotal-b.timetotal}).map(e=>e.timetotal/3600000),
				}
			]
		};

		dataGuesses = {
			labels: puzzleLabels,
			datasets: [
				{
					label: 'อัตราส่วนของจำนวนครั้งที่ตอบผิดกับจำนวนที่ตอบถูก',
					backgroundColor: 'rgb(255, 99, 132)',
					borderColor: 'rgb(255, 99, 132)',
					data: answerlogs.map(e=>e.incorrect/e.correct)
				}
			]
		};

		dataRatings = {
			labels: puzzleLabels,
			datasets: [
				{
					label: 'ความสนุก',
					backgroundColor: 'rgb(99, 255, 132)',
					borderColor: 'rgb(99, 255, 132)',
					data: answerlogs.map(e=>e.fun/e.num)
				},
				{
					label: 'ความยาก',
					backgroundColor: 'rgb(255, 99, 132)',
					borderColor: 'rgb(132, 99, 255)',
					data: answerlogs.map(e=>e.difficulty/e.num),
				}
			]
		};

		ctxTime = chartTime.getContext('2d')
		ctxGuesses = chartGuesses.getContext('2d')
		ctxRatings = chartRatings.getContext('2d')

		configTime = {type: 'line', data: dataTime,
			options: {
				scales:{
					y:{
						display:true, 
						title:{display:true, text:'ชั่วโมง'
					}
		}}}};
		configRatings = {type: 'bar',data: dataRatings,options: {}};
		configGuesses = {type: 'bar',data: dataGuesses,options: {}};
		
		chart1 = new Chart(ctxTime, configTime)
		chart2 = new Chart(ctxGuesses, configGuesses)
		chart3 = new Chart(ctxRatings, configRatings)
	});
</script>

<div class="container">
<h1>ที่มา</h1>
ก่อนหน้านี้ในงาน Thailand Board Game Show 2020 ได้มีการจัดกิจกรรมแก้ปริศนาในงาน โดยงานนั้นซูมจัดการ 100% เนื่องจากผมยุ่งตัวเป็นเกลียว

ในปีนี้ ผู้จัดงาน Thailand Board Game Show 2021 เลยไว้ใจให้จัดกิจกรรมแก้ปริศนาอีกครั้งหนึ่ง นั่นก็คือเป็นครั้งที่สองของทั้ง TBS และทั้ง Code Breaker

<h1>เครื่องมือ</h1>
แพลตฟอร์มที่ใช้คือ gather.town จึงนับว่าเป็นกิจกรรมปริศนาออนไลน์เต็มรูปแบบ โดยใน gather.town ผู้ใช้งานจะมีปฏิสัมพันธ์กับสิ่งของได้ดังนี้
<ul>
	<li>แสดงข้อความหรือภาพเมื่อเดินไปใกล้ช่อง (prompt message)</li>
	<li>กด x เพื่อเปิดสื่อ ได้แก่ โน้ต, เว็บไซต์, วีดีโอ, ภาพ</li>
</ul>

ถ้ามี role เป็น admin, owner หรือ builder จะทำได้มากกว่านี้ คือเพิ่มสิ่งกีดขวาง และเพิ่มจุดวาร์ปไปช่องอื่น แต่เนื่องจากไม่มี role เหล่านั้นเลยไม่สามารถใช้ลูกเล่นนั้นได้ ทำให้ต้องเปลี่ยนปริศนาข้อนึงที่ให้ผู้เล่นเดินเขาวงกตล่องหน ให้เป็นเดินหาข้อความแทน <br><br>

ตอนก่อนเริ่มงาน ได้เข้าไปวางของในแผนที่ เชคของเป็นครั้งคราวเพราะคนอื่นต้องเข้ามาจัดบูธเวลาเดียวกัน บางทีของที่ตั้งไว้ก็โดนลบไป (แต่เราก็ไปลบของคนอื่นโดยไม่ได้ตั้งใจเหมือนกัน เช่นเรือโจรสลัดลำใหญ่มหึมาของ Siam Board Games ที่น่าจะเผลอลบไป 3 ครั้ง ได้)

<h1>ทำไมกลายเป็นเว็บไปได้?</h1>
<p>ในตอนแรกสุดมีการวางแผนให้ผู้เล่นต้องเดินไปหาสตาฟเพื่อตรวจคำตอบ แต่ในเมื่อเราเล่นแบบออนไลน์รูปแบบอยู่แล้ว ถ้ามีหน้าสำหรับตรวจคำตอบให้เลยจะสะดวกกว่า จึงคิดว่าจะใช้แนบลิงก์ Google Sites หรือ Google Forms ให้ใน gather.town เลย แต่ไป ๆ มา ๆ ด้วยความที่เพิ่งได้รู้จักกับ Svelte หมาด ๆ เลยคันมือทำเป็น web app ซะเลย</p>

<p>ที่จริง มี github project ที่ใช้สร้างเว็บสำหรับ puzzle hunt โดยเฉพาะ ที่ <a href="https://github.com/galacticpuzzlehunt/gph-site" target="blank">gph-site</a> และได้เคยลอง fork มาทำเล่นจนเสร็จแล้ว แต่ติดตรงที่ต้องให้ผู้เล่นสร้างบัญชีในเว็บ ซึ่งจะวุ่นวายถ้าต้องกรอกข้อมูลนู่นนี่นั่นเพียงเพื่อแก้ปริศนาสั้น ๆ (ที่.... อะ เดี๋ยวตามอ่านต่อดีกว่า) เลยไม่สามารถใช้ได้ อย่างไรก็ตาม ลูกเล่นหลายอย่างก็หยิบจาก gph-site นี่หละ เอามาเขียนใหม่เอง </p>

<p>ตอนแรก ๆ ก็กะว่าทำเป็นหน้าแยกกัน ตรวจคำตอบแล้วจบ อย่างน้อยสุดก็ให้ผู้เล่นกรอกชื่อและอีเมลหลังเล่นเสร็จ เพื่อส่งให้ทีมงานไปแจกรางวัล แต่นึกสนุกอยากทำให้เหมือน puzzle hunt ที่เคยไปเล่น ก็เลยใส่ลูกเล่นเพิ่ม ไป ๆ มา ๆ กลายเป็น full-stack ไปได้ (...) ถ้ามี login ด้วยนี่คือครบเลย
<br>
(tech ที่ใช้เขียนเว็บได้แก่: Svelte, Sapper, Node.js, PostgresSQL
host บน Heroku ส่วน user interface ใช้ <a href="https://sveltematerialui.com/" target="blank">Svelte Material UI</a>)
</p>

ลูกเล่นที่วางแผนใส่ในเว็บ และใส่เป็นที่เรียบร้อยแล้ว เป็นลำดับตามนี้

<ol>
	<li>แสดงคำใบ้ - ส่วนนี้ให้เป็นอันดับ 1 เลย และทำเสร็จก่อน</li>
	<li>ตารางอักษร - ตอนแรกวางแผนใช้ภาพนิ่ง แต่นึกได้ว่าถ้าทำให้ตารางเป็นปุ่มช่วยทดด้วย น่าจะเล่นสะดวกขึ้นมาก ก็เลยออกมาเป็นอย่างที่เห็น ที่จริงซ่าคิดจะให้ใส่สีใส่อะไรได้ แต่กลัวจะไม่ได้ทำอย่างอื่นเลยพับไป</li>
	<li>ตรวจคำตอบบน server - ตอนแรกว่าจะฝังคำตอบที่เข้ารหัสไว้ใน javascript เลย แต่ด้วยความที่ต้องใช้ server เพื่อทำอย่างอื่นอยู่แล้วเลยตรวจคำตอบบน server ไปเลย ส่วนหนึ่งก็คือกันโกงนั่นแหละ แต่อีกส่วนคือจะได้เก็บข้อมูลอื่น ๆ ได้ ไว้ย้ายหน้าเว็บเป็นแบบ serverless แล้วค่อยแก้</li>
	<li>บันทึกคำตอบ - ผู้เล่นบางคนไม่ได้เล่นต่อเนื่องตั้งแต่ต้นจนจบ เลยเพิ่มลูกเล่นนี้ขึ้นมา จะได้ไม่ต้องขุดคำตอบเก่า ๆ มาตอบใหม่อีกที นอกจากนั้นทำให้สามารถกันไม่ให้ใช้เครื่องเดียวกันส่งคำตอบซ้ำ ๆ หลายครั้ง เพื่อกรอกอีเมลหลีายคนได้ (แต่ถ้า clear cache เป็นก็ทำได้อยู่ดีแหละ...) <br><br> ซึ่งกลายเป็นว่าลูกเล่นสำคัญในด่านที่ 2 เพราะว่าผู้เล่นต้องเดินไปมาระหว่างกระดาน ถ้าต้องทดคำตอบแล้วเดินมาตอบที่กระดานกลางก็จะดูน่าหงุดหงิดมาก เลยเก็บคำตอบไว้ใช่ระหว่างหน้าได้
	</li>
	<li>กระดานคะแนน - ตอนแรกไม่ได้คิดถึงขั้นนี้ เพราะรู้ว่าต้องสร้าง database ซึ่งไม่เคยใช้มาก่อนเลย แต่พอคิดขึ้นได้ว่าสุดท้ายต้องเก็บข้อมูลผู้เล่นที่เล่นจบอยู่ดี เลยไปศึกษาและโชคดีที่ทำเสร็จได้ไม่ยากนัก เนื่องจาก heroku มี PostgresSQL เป็น add-on ให้อยู่แล้ว</li>
	<li>เก็บข้อมูลเวลา และจำนวนครั้งที่ตอบผิด - อธิบายละเอียดด้านล่าง ข้อมูลเหล่านี้จะเป็นประโยชน์มากเวลาออกแบบกิจกรรมปริศนาในภายภาคหน้า ซึ่งส่วนนี้ทำได้ไม่ยากเพราะต้องตรวจคำตอบบน server อยู่แล้ว</li>
	<li>Discord - ได้ไอเดียมาจาก gph-site ที่แจ้งเตือนใน Discord ทุกครั้งที่มีการส่งคำตอบ เลยลองทำขึ้นมาดูบ้าง เนื่องจากเป็นระบบส่งข้อความอย่างเดียว เลยสามารถใช้ webhook ได้ ไม่ต้องถึงขั้นเขียน bot <br><br>
	ทีแรกก็ว่าจะมาเชคเป็นบางครั้งบางคราว แต่ปรากฏว่าอ่านแล้วสนุก ก็เลยแทบจะเปิดค้างไว้... โดยเฉพาะตอนที่เข้าไปดูคนอื่นเล่นอยู่ ทำให้บางครั้งสามารถเดินเข้าไปบอกคำใบ้ได้เลย (แต่ใจนึงก็กลัวเป็น unsolicited advice ยังไงไม่รู้)
	</li>
	<li>ให้คำใบ้เวลาคำตอบใกล้เคียง - ข้อดีของการเล่นบนเว็บคือ สามารถให้คำใบ้ได้ถ้ามาถูกทางแล้วแต่ยังตอบไม่ถูก โดยเฉพาะข้อที่เมื่อแก้ในขั้นแรกแล้วได้วลี ที่ต้องเอาไปทำต่ออีกทีหนึ่ง (ในภาษา puzzle hunt คือ keep going)<br><br>

	สิ่งที่ต่างจาก puzzle hunt ทั่วไปคือ แจ้งให้ผู้เล่นทราบถ้าคำตอบผิดไปเพียง 1 ตัวอักษร ซึ่งในกิจกรรมปริศนาปกติจะไม่ค่อยมีกัน เพราะถ้าผิดแล้วจะผิดแบบไปคนละโลกเลย แต่ด่านที่ 1 มีความแปลกตรงที่ให้หาตำแหน่งของตัวอักษรในตาราง ทำให้บางครั้งผู้เล่นอาจอ่านผิดไปเป็นช่องข้าง ๆ แทน หรือตัวอักษรบางตัวอาจจะยากเกินไป (เช่น มีชู้ = #) ทำให้หาได้ไม่ครบ จึงดูสมเหตสมผลที่จะแจ้งให้<br><br>

	จะเห็นว่า ลูกเล่นนี้ใส่ไว้ตอนท้าย ๆ ... ไม่ใช่ว่าไม่สำคัญ แต่เพราะรู้ว่าใช้เวลาไม่นานมาก 
	</li>
	<li>แชร์ลงโซเชียล - ได้รับแรงบันดาลใจจากปริศนาใน LINE ของค่าย riddler ว่าเวลาเล่นจบแล้วเราอยากแชร์ (=ขิง) ว่าได้อันดับเท่าไหร่ ดีที่มีคนเขียน component ไว้ให้ใช้ได้เลย ไม่ต้องขุด api มาศึกษาเอง (แต่ที่จริงก็อ่านไประดับนึงละ)</li>
	<li>ให้คะแนนปริศนา - ในเมื่อมี database แล้ว ก็เลยนึกสนุกอยากเก็บข้อมูลให้มากขึ้น เลยใส่ระบบลงคะแนนหลังจากตอบเสร็จแล้ว</li>
</ol>

รายการสิ่งที่อยากทำแต่ไม่ได้ทำ
<ul>
	<li>Notification - แจ้งเตือน เตือนอะไร? เตือนให้ทุกคนเห็นว่ามีคนแก้ข้อนี้ได้แล้ว! เนื่องจากใช้ socket.io อยู่แล้วเลยทำได้ไม่ยาก แต่คิดไปคิดมาคนเล่นน่าจะรู้สึกกดดันมากกว่าท้าทาย ก็เลยพับไป เหลือเพียงแค่นับจำนวนคนที่เล่น ณ เวลานั้น</li>
	<li>แก้ snackbar - หลังจากที่ผู้เล่นส่งคำตอบ จะมีข้อความโผล่ด้านล่างว่าถูกหรือไม่ (snackbar) โดยใช้ของ default บน Svelte Material UI แต่พอใช้จริงก็มีปัญหาว่าโผล่สั้นไป ตัวอักษรเล็กไป หรือไปชนกับ interface ของ gather.town แต่ว่าไม่ได้ย้อนกลับมาทำส่วนนี้ เพราะเท่าที่มีอยู่ก็พอใช้ได้แล้ว รอบหน้าต้องหาทางออกใหม่</li>
	<li>Badge - เรามี point แล้ว (นับว่าทำเสร็จไปกี่ข้อ) มี leaderboard แล้ว จะครบสามเกลอ PBL ได้ก็ต้องเพิ่ม badge สิ! แต่พอจะนั่งเขียนโค้ดก็เห็นว่าต้องเก็บข้อมูลเยอะมาก และละเอียดมาก (เช่น badge คนที่คลิกตารางครบ 100 ครั้ง) ก็เลยล้มเลิกไป แต่งานหน้าก็อาจซ่าลองทำดู</li>
	<li>ห้องแชท - ถ้าผู้เล่นที่เล่นพร้อมกันสามารถส่งข้อความหากันได้ทันทีเลย ก็ดูน่าสนุกนะ แต่ต้องกรองแสปม กันสปอยล์ ก็เลยไม่ได้ทำ และในงานจริงก็ค้นพบว่าผู้เล่นส่งข้อความคุยกันใน gather.town กันได้ ก็เลยคิดว่าดีแล้วที่ไม่ไปทำซ้ำซ้อน </li>
	<li>ใส่เสียง - พยายามมาพักนึง อยากให้มีเสียงกระดิ่งเวลาตอบถูกหรือเสียงออดเวลาตอบผิด เพิ่ม immediate feedback แต่ไม่สำเร็จ ทั้ง ๆ ที่เป็น html ปกติซะด้วยซ้ำ รอบหน้าแก้ตัวใหม่</li>
</ul>

หลังจากงานนี้เสร็จสิ้นและย้ายหน้าเว็บไปเป็นแบบ static เรียบร้อย และลบรหัสสำคัญ (database, webhook) แล้ว จะลงลิงก์ source code ให้เอาไป fork ต่อได้ตามอัธยาศัย

<h1>เวลาที่ใช้</h1>
<p>เนื่องจากงานนี้จัดเพียง 3 วัน และมีกิจกรรมอื่นในงานให้ร่วมสนุกอีก เลยไม่อยากให้ใช้เวลากับปริศนามากเกินไป จึงได้เก็บข้อมูลว่าผู้เล่นใช้เวลากับปริศนาเท่าไหร่ แต่เป็นการเก็บข้อมูลแบบหยาบ ๆ นั่นคือ จับเวลาเริ่มครั้งเดียวตอนที่เปิดหน้าปริศนาครั้งแรก และนับจนถึงเวลาที่ส่งคำตอบสุดท้ายของด่าน 1 และด่าน 2 จึงมีบางคนที่เปิดวันแรก แต่ได้เริ่มเล่นจริงวันสุดท้าย ทำให้เวลาไม่ตรงกับความเป็นจริง ึึ</p>

ฉะนั้นจึงตัดเวลาที่เกิน 10 ชั่วโมงออก และนำเวลาที่เหลือมาเรียงลำดับได้ตามนี้
<div class="chart">
	<canvas bind:this={chartTime}></canvas>
</div>

<p>ครึ่งนึงของผู้เล่นจบด่านที่ 1 ได้ใน 2 ชั่วโมง นานกว่าที่คิดไว้มากกกกกกกก เพราะมี 6 ข้อ แต่ต้องเดินรอบแผนที่ด้วย ก็เลยบอกไม่ได้ว่านานที่ปริศนาเอง หรือนานเพราะหาคำใบ้ </p>

<p>และจบด่านที่ 2 ใน 4 ชั่วโมง ถ้าหักด่านแรกก็เหลือ 2 ชั่วโมง ก็คือพอ ๆ กัน (แต่ไม่ต้องเดินรอบแผนที่แล้ว) </p>

<p>โดยรวมนับว่าสนุกสำหรับคนที่ชอบเล่นอยู่แล้ว นั่นคือ 11 ข้อ ข้อละ 20 นาทีแต่ก็นานเกินไปมากโขถ้าเป้าหมายการออกแบบคือบุคคลทั่วไป </p>

<p>แต่ก็จะเห็นได้ว่า มีผู้เล่นจำนวนหนึ่งที่ใช้เวลาถึง 3 ชั่วโมงในด่านที่ 1 และ 6 ชั่วในด่านที่ 2 ส่วนผู้เล่นที่ใช้เวลาถึง 8 ชั่วโมง มีถึง 7 คน ก็ไม่น่าจะใช่เรื่องบังเอิญที่จะเป็นกลุ่มที่ไม่ได้เล่นต่อเนื่องทั้งหมด </p>

<h1>จำนวนครั้งที่ตอบผิด</h1>
<p>ก่อนจะถึงเป้าหมายก็ต้องมีการล้มลุกคลุกคลานกันบ้าง เลยรวบรวมว่าข้อไหนที่มีคนตอบผิดเยอะสุด โดยวัดจากอัตราส่วนคำตอบที่ผิด และคำตอบที่ถูก</p>
<div class="chart">
	<canvas bind:this={chartGuesses}></canvas>
</div>
เช่น ในข้อ 1-1 (ปลา) โดยเฉลี่ยแล้วผู้เล่นจะตอบผิด 2 ครั้ง ก่อนจะตอบถูก 1 ครั้ง ส่วนข้อ 2-2 (วงกลม) ผู้เล่นจะตอบผิด 15 ครั้งก่อนจะเจอคำตอบที่ถูก (!!!) ซึ่งนับว่าเยอะมาก

<h1>คะแนนโหวต</h1>

ลูกเล่นนึงคือ การให้คนเล่นลงคะแนนหลังจากแก้ปริศนาเสร็จ เพื่อจะได้รับ feedback ทันที โดยมีข้อมูลสรุปดังนี้
<div class="chart">
	<canvas bind:this={chartRatings}></canvas>
</div>
<small>หมายเหตุ - เอ๊ะ ข้อสุดท้ายหายไปไหนนะ? อ้อ ถ้าตอบข้อสุดท้ายถูกแล้วจะเปลี่ยนไปหน้ากรอกข้อมูลทันที เลยไม่มีคนลงกลับมาลงคะแนนให้...</small>

<p>คะแนนความสนุกไม่ห่างกันเลย อยู่ 3.7 - 4.3 อันนี้ไม่รู้เหมือนกันว่าทำไมเกาะกลุ่มกัน เพราะโจทย์คล้าย ๆ กัน เพราะความสนุกกะยาก หรือเพราะไม่กล้าโหวตว่าไม่สนุกกันนะ</p>

<h1>ความเห็น</h1>
หลังจากที่เล่นจบด่าน 2 แล้ว ได้เปิดโอกาสให้ผู้ชนะได้ส่งความเห็นสั้น ๆ มา ซึ่งรวบรวมได้ดังนี้
<div>

<table>
{#each comments as comment}
	<tr>{comment}</tr>
{/each}
</table>
</div>

<h1>มองย้อน</h1>

<h2>ด้านของปริศนา</h2>
<p></p>

<h2>ด้านการเขียนเว็บ</h2>
<p>นับว่าประสบความสำเร็จ เพราะไม่ได้มีเป้าหมายจะมาไกลขนาดนี้ในทีแรก</p>

<h2>ด้านผลตอบรับของผู้เล่น</h2>
<p></p>

<h2>รอบหน้าอยากแก้อะไร</h2>
<ul>
	<li>อยากใส่ลูกเล่นที่เล่นบนเว็บ (เช่น https://2020.galacticpuzzlehunt.com/puzzle/so-you-think-you-can-spell#right)</li>
	<li>อยากใส่โจทย์ความรู้ทั่วไป (trivia) ที่เกี่ยวกับบอร์ดเกม เป็นส่วนหนึ่งของปริศนา</li>
	<li></li>
	<li>ระวังเรืองตำแหน่ง - ข้อที่มีคนตอบผิดมากเป็นอันดับ 2 คือ ข้อ 1-5 (ดาบ) เพราะผู้เล่นมองไม่ออกว่าดาบห่างจากช่องที่ยืนอยู่กี่ช่อ</li>
</ul>
</div>

<style>
	@import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300&display=swap');

	h1{
		text-align: center;
		margin: 20px;
	}

	.container{
		font-family: 'Chakra Petch', sans-serif;
		font-size: 16pt;
		display: flex;
		flex-direction: column;
		width: 800px;
		margin: auto;
		justify-content: left;
		align-items: left;
	}

	.chart{
		display: block;
		width: 100%;
		height: auto;
		margin: auto;
	}

	tr:nth-child(odd) {
		background-color: #dddddd;
	}
</style>